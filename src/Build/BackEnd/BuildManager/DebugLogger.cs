using System;using System.Collections;using System.Collections.Generic;using System.Collections.Immutable;using System.Diagnostics;using System.IO;using System.Linq;using System.Runtime.CompilerServices;using System.Text.RegularExpressions;using System.Threading;using Microsoft.Build.BackEnd;using Microsoft.Build.Evaluation;using Microsoft.Build.Execution;using Microsoft.Build.Framework;namespace Microsoft.Build.Shared{    internal static class DebugUtils    {        //public static string ExecutionId => $"{Process.GetCurrentProcess().Id}_{Process.GetCurrentProcess().ProcessName}_{Thread.CurrentThread.Name}-{Thread.CurrentThread.ManagedThreadId}";        public class CsvPrinter        {            private const string DefaultPath = @"e:\delete\events";            public static CsvPrinter Default = new CsvPrinter(DefaultPath, @"events.csv");            public static CsvPrinter Error = new CsvPrinter(DefaultPath, "Error.csv");            private readonly string _directory;            private readonly string _fileName;            private readonly string _path;            public bool WriteTimeStamp { get; set; } = true;            public CsvPrinter(string fullPath) : this(Path.GetDirectoryName(fullPath), Path.GetFileName(fullPath))            {            }            public CsvPrinter(string directory, string fileName)            {                _directory = directory;                _fileName = fileName;                Directory.CreateDirectory(_directory);                _path = Path.Combine(_directory, _fileName);            }            public static CsvPrinter WithFullPath(string path)            {                return new CsvPrinter(path);            }            public static CsvPrinter WithFileName(string fileName)            {                return new CsvPrinter(DefaultPath, fileName);            }            public static CsvPrinter WithExecutionId(string prefix = "", string suffix = "")            {                return new CsvPrinter(DefaultPath, prefix + ExecutionId + suffix);            }            public void WriteCsvLine(params object[] elements)            {                var counter = 0;                while (true)                    try                    {                        IEnumerable<object> elementsToPrint = elements;                        if (elements.Length == 1)                        {                            switch (elements[0])                            {
                                case List<object> listOfObject:                                    elementsToPrint = listOfObject;                                    break;                                case List<string> listOfString:                                    elementsToPrint = listOfString;                                    break;
                                case IEnumerable<object> enumerableOfObject:                                    elementsToPrint = enumerableOfObject;                                    break;
                            }                        }                        elementsToPrint = WriteTimeStamp                            ? new object[] { DateTime.Now.ToString("HH:mm:ss:fff") }.Concat(elementsToPrint)                            : elementsToPrint;                        var line = string.Join(",", elementsToPrint) + "\n";                        File.AppendAllText(_path, line);                        break;                    }                    catch (Exception e)                    {                        counter++;                        Thread.Sleep(TimeSpan.FromMilliseconds(50));                        PrintError(e, $"Exception to {_path}. Retry {counter}");                    }            }            public void PrintError(Exception exception, string message)            {                try                {                    var file = Path.Combine(                        _path + "_DebugUtilsError_" + Guid.NewGuid()                            .ToString("N"));                    message = $"{message}\ne.message: {exception.Message}\n{EscapeForCsv(exception.StackTrace)}";                    File.WriteAllText(file, message);                }                catch (Exception e)                {                    message = $"{message}\ne.message: {exception.Message}\n{EscapeForCsv(exception.StackTrace)}";                    var errorFile = Path.Combine(_directory, $"Error_{Guid.NewGuid():N}");                    File.WriteAllText(errorFile, message);                    VSBreakpoint();                    throw;                }            }            private void PrintStackOnError(Action action, [CallerMemberName] string caller = null)            {                try                {                    action();                }                catch (Exception e)                {                    PrintError(e, caller);                }            }            public void WriteBuildEvent(BuildEventArgs eventArgs, int eventArgsHashCount = 0, int packetHashCount = 0, INodePacket packet = null)            {                PrintStackOnError(                    () =>                    {                        var message = new List<string>();                        bool write = false;                        BuildEventContext eventContext = eventArgs.BuildEventContext;                        message.Add(                            eventContext != null                                ? eventContext.NodeId.ToString()                                : "NA");                        message.Add(                            eventContext != null                                ? $"ProjectContextId={eventContext.ProjectContextId}"                                : "NA");                        switch (eventArgs)                        {                            case TargetStartedEventArgs targetStarted:                                write = true;                                message.AddRange(                                    new List<string>                                    {                                        "Target Started",                                        targetStarted.TargetName,                                        $"TargetId={eventContext.TargetId}"                                    });                                break;                            case TargetFinishedEventArgs targetEnded:                                write = true;                                message.AddRange(                                    new List<string>                                    {                                        "Target Finished",                                        targetEnded.TargetName,                                        $"TargetId={eventContext.TargetId}"                                    });                                break;                            case ProjectStartedEventArgs projectStarted:                                write = true;                                message.AddRange(                                    new List<string>                                    {                                        "Project Started",                                        projectStarted.ProjectFile,                                        $"Targets=[{projectStarted.TargetNames}]"                                    });                                break;                            case ProjectFinishedEventArgs projectFinished:                                write = true;                                message.AddRange(                                    new List<string>                                    {                                        "Project Finished",                                        projectFinished.ProjectFile                                    });                                break;                            //case BuildStartedEventArgs buildStarted:                            //    write = true;                            //    message.AddRange(                            //        new List<string>                            //        {                            //            "Build Started",                            //            "Build",                            //        });                            //    break;                            //case BuildFinishedEventArgs buildFinished:                            //    write = true;                            //    message.AddRange(                            //        new List<string>                            //        {                            //            "Build Finished",                            //            "Build",                            //            $"Succeeded: {buildFinished.Succeeded}",                            //            $"Message: {buildFinished.Message}",                            //        });                            //    break;                        }                        message.Add($"eventArgsHash={eventArgs.GetHashCode()}");                        message.Add($"eventArgsHashCount={eventArgsHashCount}");                        message.Add($"packetHash={packet?.GetHashCode()}");                        message.Add($"packetHashCount={packetHashCount}");                        if (write)                        {                            WriteCsvLine(message.ToArray());                        }                    });            }            private static string EscapeForCsv(string aString)            {                return aString.Replace(',', ';');            }            public void WriteBuildResult(BuildResult result)            {                PrintStackOnError(                    () =>                    {                        var message = new List<object>                        {                            $"SubmissionId={result.SubmissionId}",                            $"OverallResult={result.OverallResult}",                            $"InitialTargets=[{string.Join(",", result.InitialTargets)}]",                            $"DefaultTargets=[{string.Join(",", result.DefaultTargets)}]"                        };                        foreach (var targetResult in result.ResultsByTarget)                        {                            message.Add($"Target={targetResult.Key}");                            message.Add($"\tResultCode={targetResult.Value.ResultCode.ToString()}");                            message.Add($"\tExceptionMessage=[{targetResult.Value.Exception?.Message ?? ""}]");                            message.Add("\tItems");                            foreach (var item in targetResult.Value.Items)                            {                                message.Add($"\t\t{item.ItemSpec}");                                foreach (string metadataName in item.MetadataNames)                                {                                    try                                    {                                        message.Add($"\t\t\t{metadataName}={item.GetMetadata(metadataName)}");                                    }                                    catch (Exception e)                                    {                                        message.Add($"\t\t\tException:{metadataName}={e.Message}");                                    }                                }                            }                        }                        WriteCsvLine(string.Join("\n", message));                    });            }            public void WriteProject(Project project)            {                PrintStackOnError(                    () =>                    {                        var message = new List<string>();                        message.Add($"File={project.FullPath}");                        message.Add($"EvaluationId={project.LastEvaluationId}");                        message.Add($"GlobalProperties");                        foreach (var globalProperty in project.GlobalProperties)                        {                            message.Add($"\t{globalProperty.Key}{globalProperty.Value}");                        }                        message.Add($"Properties");                        foreach (var property in project.Properties)                        {                            message.Add($"\t{property.Name}={property.EvaluatedValue}");                        }                        message.Add($"Items");                        foreach (var item in project.Items)                        {                            message.Add($"\t{item.ItemType}={item.EvaluatedInclude}");                            foreach (var metadata in item.MetadataCollection)                            {                                message.Add($"\t\t{metadata.Name}={metadata.EvaluatedValue}");                            }                        }                        WriteCsvLine(string.Join("\n", message));                    });            }            public void WriteNodePacket(INodePacket packet, IConfigCache configCache)            {                PrintStackOnError(                    () =>                    {                        var message = new List<object> {$"Received {packet.Type}"};                        switch (packet)                        {                            case BuildRequest buildRequest:                                var brq = configCache[buildRequest.ConfigurationId];                                message.Add($"SubmissionId={buildRequest.SubmissionId}");                                message.Add($"{brq.ProjectFullPath}");                                break;                            case NodeConfiguration nodeConfiguration:                                message.Add($"KeepInProcNode={!nodeConfiguration.BuildParameters.ShutdownInProcNodeOnBuildFinish}");                                break;                            case BuildResult buildResult:                                message.Add($"SubmissionId={buildResult.SubmissionId}");                                message.Add($"Result={buildResult.OverallResult}");                                message.Add($"Exception={buildResult.Exception?.Message ?? string.Empty}");                                break;                        }                        WriteCsvLine(message);                    });            }        }        public enum NodeMode        {            Central,            OutOfProcNode,            OutOfProcTaskHostNode        }        public static string ExecutionId => $"NodeMode={GetNodeMode()}_PID={Process.GetCurrentProcess() .Id}_{Process.GetCurrentProcess() .ProcessName}";        public static void VSBreakpointWhenFileExists(string file)        {            if (!Debugger.IsAttached && File.Exists(file))            {                File.AppendAllText(                    file,                    $"{Process.GetCurrentProcess() .Id}\n");                while (!Debugger.IsAttached)                {                }                Debugger.Break();            }        }        public static void VSBreakpointFileNotification(string file)        {            if (!Debugger.IsAttached)            {                File.AppendAllText(                    file,                    $"{Process.GetCurrentProcess() .Id}\n");                while (!Debugger.IsAttached)                {                }                Debugger.Break();            }        }        public static void VSBreakpoint()        {            if (!Debugger.IsAttached)            {                while (!Debugger.IsAttached)                {                }                Debugger.Break();            }        }        public static bool HasDTB(BuildRequestData request)        {            return HasPropertiesTrue(request, "SkipCompilerExecution", "ProvideCommandLineArgs");        }        public static NodeMode GetNodeMode()        {            return ScanNodeMode(Environment.CommandLine);            NodeMode ScanNodeMode(string input)            {                var match = Regex.Match(input, @"/nodemode:(?<nodemode>[12\s])(\s|$)", RegexOptions.IgnoreCase);                if (!match.Success)                {                    return NodeMode.Central;                }                var nodeMode = match.Groups["nodemode"].Value;                Trace.Assert(!string.IsNullOrEmpty(nodeMode));                switch (nodeMode)                {                    case "1":                        return NodeMode.OutOfProcNode;                    case "2":                        return NodeMode.OutOfProcTaskHostNode;                    default:                        throw new NotImplementedException();                }            }        }        public static bool HasPropertiesTrue(BuildRequestData request, params string[] properties)        {            var propertySet = properties.ToImmutableHashSet();            return HasPropertiesTrue(request.GlobalProperties, propertySet) ||                   HasPropertiesTrue(request?.ProjectInstance.Properties, propertySet);        }        private static bool HasPropertiesTrue(            IEnumerable<ProjectPropertyInstance> properties,            ISet<string> propertyNames)        {            return properties != null &&                   properties.Any(                       p => propertyNames.Contains(p.Name, StringComparer.OrdinalIgnoreCase) &&                            p.EvaluatedValue.Equals("true", StringComparison.OrdinalIgnoreCase));        }    }}